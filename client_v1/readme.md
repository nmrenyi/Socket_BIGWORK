# 网络对战国际象棋软件设计文档
## 2018011423 任一

### 一、网络通信编程框架与国际象棋逻辑框架
1. 从网络连接的角度看，客户端和服务器共用了一个项目。其中server.h和server.cpp主要是服务器端弹出的窗口，connectto.h和connectto.cpp主要是用户端弹出的窗口。
2. 从下棋逻辑的角度看，mainwindow.cpp和mainwindows.h主要负责主界面的显示、画图画棋子、按钮逻辑的实现。board.h和board.cpp作为棋盘类，主要负责棋盘层面逻辑的实现，内含棋子Piece的二维数组。piece.h和piece.cpp主要负责棋子的逻辑和性质，例如棋子的颜色和名称。

### 二、客户端与服务器端工作流程简介
1. 服务器端输入IP地址和端口之后，QTcpServer就启动监听，进入等待连接的阶段。若此时服务器端取消等待，则调用listenSocket->close()函数来停止监听。
2. 之后客户端输入服务器的IP和端口后，发出connectToHost请求。
3. 此时服务器接收到客户端的请求，发出newConnection()信号，启动了acceptNewConnection()槽，弹出客户端已经连接成功的消息。此时客户端与服务器端成功建立了链接。
4. 如果一方需要发送信息，则调用readWriteSocket->write()函数进行发送消息。另一方读取消息则调用readWriteSocket->readAll()函数进行读取。

### 三、客户端与服务器端通信协议
我们需要将当前的棋局转换为字符串来方便socket传输。本项目中服务器端和客户端通信协议基本与残局输入保存相仿。不同之处如下:
1. 在棋盘传输时，传入下一步应该哪一方走，若为白方走则传入"true\n",黑方走则传入"black\n"(默认服务器端为白方，客户端为黑方，由bool myID控制，若为白方，则myID = true, 若为黑方，则myID = false)只有当myID与当前走棋方一致的时候，点击棋子才有效。
2. 若点击了NewGame或ReadFile，则传输"newRound\n"信息。若接受到"newRound\n"，则重置当前棋盘状态和倒计时，以便重新开始游戏状态。
3. 若白方胜，则传递"blacklose\n"信号。若收到"blacklose\n"信号，则弹窗进行提示。黑方胜亦然。
4. 由于每一条信息后都加有"\n"，读取信息时按行读取，所以信息的发送和读取都较为简单。

### 四、国际象棋逻辑简介
棋子逻辑的推进主要依靠鼠标的点击进行，因此本文主要从鼠标点击的角度进行介绍。
1. 如果收到左键单击信息并且当前端为走棋端，则判断是否已经选中了棋子。
2. 若尚未选中棋子，且点击的格子有棋子，则计算哪些格子是当前选中棋子可以走的并且显示当前可走的格子(该计算过程主要考虑了当前棋子身份所对应的行走规则，允许的行走路线上有没有棋子，是敌是友等内容)
2. 若当前已经选中了某个棋子，则将本次点击划分三种情况:一是点击到已选中的棋子，则将该棋子放下。二是选中了当前棋子不能走的格子，也将该棋子放下。三是选中了当前棋子可以走的格子，则直接将当前棋子覆盖到选中的格子当中，无需考虑选中的格子当中有没有棋子(在2中的计算过程已有考虑)，之后发送棋盘信息给对方。此次点击之后检查棋盘上黑白双方是否没有了王，如果没有则弹出对应的提示信息并且发送胜败信息给对方端。
3. 若当前点击触发了兵的升变，则弹出窗口进行选择，点击确认之后则可显示新升变的棋子，并且传输升变后的棋盘信息给对方端。
